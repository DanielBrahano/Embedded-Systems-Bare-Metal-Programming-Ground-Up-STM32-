//Where is the led connected?
//Port:	A
//Pin:	5

#include <stdint.h>  // Include this header file for fixed-width integer types
#include <stddef.h>  // Include this header file for size_t and NULL (optional but common)

#define PERIPH_BASE				(0X40000000ul) //(ul = unsigned long)
#define AHB1PERIPH_OFFSET		(0X00020000UL)
#define AHB1PERIPH_BASE 		(PERIPH_BASE + AHB1PERIPH_OFFSET)
#define GPIOA_OFFSET			(0x0000UL)

#define GPIOA_BASE				(AHB1PERIPH_BASE + GPIOA_OFFSET)

#define RCC_OFFSET				(0x3800UL)	//we need the RCC to enable clock access to GPIO A
#define RCC_BASE				(AHB1PERIPH_BASE + RCC_OFFSET)


#define AHB1EN_R_OFFSET			(0X30UL)	// EN - enable, R - register
#define RCC_AHB1EN_R			(*(volatile unsigned int *)(RCC_BASE + AHB1EN_R_OFFSET))

#define MODE_R_OFFSET			(0x00UL)
#define GPIOA_MODE_R			(*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))


#define OD_R_OFFSET				(0x14UL)
#define GPIOA_OD_R				(*(volatile unsigned int *)(GPIOA_BASE + OD_R_OFFSET))


#define GPIOAEN					(1U << 0) // shift '1' to position 0 (enable GPIO A clock)

#define PIN5					(1U << 5)
#define LED_PIN 				PIN5

#define __IO volatile

//typedef struct
//{
//
//};GPIO_TypeDef;

typedef struct
{
	volatile uint32_t MODER;    /*!< GPIO port mode register,               	Address offset: 0x00 */
	volatile uint32_t DUMMY[4];
	volatile uint32_t ODR;      /*!< GPIO port output data register,        	Address offset: 0x14 */
} GPIO_TypeDef;

typedef struct
{
	volatile uint32_t DUMMY[12];
	volatile uint32_t AHB1ENR;  /*!< RCC AHB1 peripheral clock enable register,    Address offset: 0x30 */
} RCC_TypeDef;

#define RCC		((RCC_TypeDef*)RCC_BASE)
#define GPIOA	((GPIO_TypeDef*)GPIOA_BASE)

int main (void)
{
	/* 1. Enable clock access to GPIOA*/
	//RCC_AHB1EN_R |= GPIOAEN;
	RCC->AHB1ENR |= GPIOAEN;
	/* 2. Set PA5 as output pin*/
//	GPIOA_MODE_R |= (1U << 10); // Set bit 10 to 1
//	GPIOA_MODE_R &=~ (1U << 11); // Set bit 11 to 0
	GPIOA->MODER |= (1U << 10); // Set bit 10 to 1
	GPIOA->MODER &=~ (1U << 11); // Set bit 11 to 0


	while (1)
	{
		/* 3. Set PA5 as output pin*/
//		GPIOA_OD_R |= LED_PIN;

		/* 4. Experiment 2: toogle PA5 */
		//GPIOA_OD_R ^= LED_PIN;
		GPIOA->ODR ^= LED_PIN;
		for (int i = 0; i < 100000; ++i) {

		}
	}
}
