//Where is the led connected?
//Port:	A
//Pin:	5

#include <stdint.h>  // Include this header file for fixed-width integer types
#include <stddef.h>  // Include this header file for size_t and NULL (optional but common)

typedef struct
{
  __IO uint32_t MODER;    /*!< GPIO port mode register,               Address offset: 0x00 */
  __IO uint32_t OTYPER;   /*!< GPIO port output type register,        Address offset: 0x04 */
  __IO uint32_t OSPEEDR;  /*!< GPIO port output speed register,       Address offset: 0x08 */
  __IO uint32_t PUPDR;    /*!< GPIO port pull-up/pull-down register,  Address offset: 0x0C */
  __IO uint32_t IDR;      /*!< GPIO port input data register,         Address offset: 0x10 */
  __IO uint32_t ODR;      /*!< GPIO port output data register,        Address offset: 0x14 */
  __IO uint32_t BSRR;     /*!< GPIO port bit set/reset register,      Address offset: 0x18 */
  __IO uint32_t LCKR;     /*!< GPIO port configuration lock register, Address offset: 0x1C */
  __IO uint32_t AFR[2];   /*!< GPIO alternate function registers,     Address offset: 0x20-0x24 */
  __IO uint32_t BRR;      /*!< GPIO port bit reset register,          Address offset: 0x28 */
} GPIO_TypeDef;

typedef struct
{
  __IO uint32_t CR;       /*!< RCC clock control register,                  Address offset: 0x00 */
  __IO uint32_t PLLCFGR;  /*!< RCC PLL configuration register,              Address offset: 0x04 */
  __IO uint32_t CFGR;     /*!< RCC clock configuration register,            Address offset: 0x08 */
  __IO uint32_t CIR;      /*!< RCC clock interrupt register,                Address offset: 0x0C */


#define PERIPH_BASE				(0X40000000ul) //(ul = unsigned long)
#define AHB1PERIPH_OFFSET		(0X00020000UL)
#define AHB1PERIPH_BASE 		(PERIPH_BASE + AHB1PERIPH_OFFSET)
#define GPIOA_OFFSET			(0x0000UL)

#define GPIOA_BASE				(AHB1PERIPH_BASE + GPIOA_OFFSET)

#define RCC_OFFSET				(0x3800UL)	//we need the RCC to enable clock access to GPIO A
#define RCC_BASE				(AHB1PERIPH_BASE + RCC_OFFSET)


#define AHB1EN_R_OFFSET			(0X30UL)	// EN - enable, R - register
#define RCC_AHB1EN_R			(*(volatile unsigned int *)(RCC_BASE + AHB1EN_R_OFFSET))

#define MODE_R_OFFSET			(0x00UL)
#define GPIOA_MODE_R			(*(volatile unsigned int *)(GPIOA_BASE + MODE_R_OFFSET))


#define OD_R_OFFSET				(0x14UL)
#define GPIOA_OD_R				(*(volatile unsigned int *)(GPIOA_BASE + OD_R_OFFSET))


#define GPIOAEN					(1U << 0) // shift '1' to position 0 (enable GPIO A clock)

#define PIN5					(1U << 5)
#define LED_PIN 				PIN5

#define __IO volatile

//typedef struct
//{
//
//};GPIO_TypeDef;

typedef struct
{
	volatile uint32_t MODER;    /*!< GPIO port mode register,               	Address offset: 0x00 */
	volatile uint32_t DUMMY[4];
	volatile uint32_t ODR;      /*!< GPIO port output data register,        	Address offset: 0x14 */
} GPIO_TypeDef;

typedef struct
{
	volatile uint32_t DUMMY[12];
	volatile uint32_t AHB1ENR;  /*!< RCC AHB1 peripheral clock enable register,    Address offset: 0x30 */
} RCC_TypeDef;

#define RCC		((RCC_TypeDef*)RCC_BASE)
#define GPIOA	((GPIO_TypeDef*)GPIOA_BASE)

int main (void)
{
	/* 1. Enable clock access to GPIOA*/
	//RCC_AHB1EN_R |= GPIOAEN;
	RCC->AHB1ENR |= GPIOAEN;
	/* 2. Set PA5 as output pin*/
//	GPIOA_MODE_R |= (1U << 10); // Set bit 10 to 1
//	GPIOA_MODE_R &=~ (1U << 11); // Set bit 11 to 0
	GPIOA->MODER |= (1U << 10); // Set bit 10 to 1
	GPIOA->MODER &=~ (1U << 11); // Set bit 11 to 0


	while (1)
	{
		/* 3. Set PA5 as output pin*/
//		GPIOA_OD_R |= LED_PIN;

		/* 4. Experiment 2: toogle PA5 */
		//GPIOA_OD_R ^= LED_PIN;
		GPIOA->ODR ^= LED_PIN;
		for (int i = 0; i < 100000; ++i) {

		}
	}
}
